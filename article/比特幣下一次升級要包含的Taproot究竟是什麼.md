# 比特幣下一次升級要包含的Taproot究竟是什麼

[BitcoinMagazine](https://ethfans.org/bitcoinmagazine)   |   25. Feb, 2019   |   871 次閱讀

![img](https://upyun-assets.ethfans.org/uploads/photo/image/81ea6b94a36a4c88a10a4c4c26e80498.jpg)

在不久的將來，比特幣使用者可能會享受到一種名為“Taproot”的技術。該技術最早由比特幣核心開發者兼Blockstream前CTO Gregory Maxwell提出，它將擴充套件比特幣的智慧合約靈活性，同時提供更好隱私保護。在區塊鏈領域，即使是最複雜的智慧合約，也很難跟常規區分開來。

儘管這是一項非常大的工程，但它不僅僅是理論，是能夠實現的。包括Pieter Wuille、Anthony Towns、Johnson Lau、Jonas Nick、Andrew Poelstra、Tim Ruffing、Rusty Russell以及Gregory Maxwell在內的幾位最高產的比特幣程式碼貢獻者正在研究一種被稱為Schnorr簽名的方案，該方案還包含了Taproot，據悉，這些升級內容都會在下一次協議更新中呈現。

本文將介紹Taproot是什麼以及它的工作原理。

## P2SH

所有比特幣本質上都被“鎖定”在指令碼中：區塊鏈中的交易中可以嵌入幾行程式碼，定義在下一個交易中如何使用這些比特幣。花費這些比特幣的條件通常包括提供簽名來證明所有權。但是還可以設定其他一些條件，例如timelocks(這部分比特幣只能在特定區塊高度或日期之後才能被使用)或multisig(多重簽名，需要在一組私鑰中的多數私鑰提供簽名的情況下才能被使用)。

還可以混合和選擇設定不同的條件，建立類型複雜的智慧合約。舉個例子，如果Alice和Bob都簽名、或者在一週後Alice單獨簽名、或者Bob單獨簽名同時提供一個密碼，就可以使用這些比特幣。滿足這三個條件中的任何一個，都是這部分比特幣的使用方式。

自2012年以來，一開始指令碼 (條件) 通常是不公開可見的；只有這些比特幣的新主人知道如何使用它們。這是通過一種名為P2SH (向指令碼雜湊支付) 的技術實現的，最初只有指令碼的雜湊值被包含在區塊鏈中。這串看似隨機打亂的數字實際上包含著一部分比特幣。當所有者使用時，他會同時展示整個指令碼以及指令碼的“解決方案”。然後，任何人都可以使用初始雜湊來檢查所提供的指令碼是否確實是鎖定比特幣的原始指令碼，並且可以立即得出滿足指令碼的執行結論。

然而，當比特幣被花掉時，目前必須表明所有滿足要求所需的條件——包括尚未滿足的條件。這有兩個主要的缺點。第一，資料量很大，尤其是條件很多的情況下。其次，這不利於隱私。所有人都可以知道這筆資金用了什麼方式使用，例如，會揭露出使用了哪種錢包甚至更多的資訊。

## MAST

為解決這兩個缺點，開發者們提出了一種使用默克爾樹的解決方案：MAST（默克爾化抽象語法樹）。簡而言之，所有的資金使用條件都被單獨進行雜湊處理（而不是組合成單個雜湊值），幷包含在一棵默克爾樹中，最終生成單個雜湊值：默克爾根，以這個默克爾根來“鎖定”比特幣。

這麼做的好處是，如果需要展示默克爾樹中的任何資料，都可使用默克爾根和一些附加資料（默克爾路徑）來驗證特定資料是否被包含在默克爾樹中。其餘的默克爾樹資訊仍然是雜湊密文狀態的。

有了MAST，意味著只需要揭示出特定的滿足條件。如果在上面的例子中，Alice在一週之後使用了這些資金，她只需要揭示這個條件（以及默克爾路徑）。沒人知道這筆錢具體是怎樣花的，可能是Alice和Bob一起花的，也可能是Bob一個人花的。這使得MAST比複雜的P2SH智慧合約在資料處理上更有效率，同時還增加了隱私性。

然而，在使用 Schnorr簽名的情況下，Taproot可以做得更好：因為MAST結構可以隱藏在一筆交易當中。

## Schnorr簽名

Schnorr簽名方案長期以來一直受到許多比特幣開發者的青睞，目前還在開發階段，它將會通過軟分叉協議升級進行部署。許多密碼學家都認為Schnorr簽名方案是這一領域中的最佳方案，因為其數學特性提供了很強的正確性，不僅不受延展性影響，而且驗證速度相對較快。

在比特幣領域，Schnorr簽名最顯著的優點是其“線性數學”（linear math），它支援簽名聚合：同一筆交易中的多個簽名可以合併為一個簽名。類似的方法也可以應用於多籤交易。將公鑰和簽名組合到“閾值公鑰”和“閾值簽名”中，可以使多籤交易與常規交易變得無法區分。

這種簽名方案還有更多有趣的使用方式。例如，可以使用其他資料來“調整”私鑰和公鑰。舉一個簡化的例子，可以通過將私鑰及其對應的公鑰都乘以2來作為新的公私鑰。“私鑰x 2”和“公鑰x 2”仍然對應，“私鑰x 2”仍然可以對使用“公鑰x 2”驗證的資訊進行簽名。任何不知道原始金鑰對被調整了的人，甚至都看不出有什麼差異；這些調整過的金鑰看起來和其他的金鑰對是一樣的。

這就衍生出了TapRoot。

## Taproot

Taproot基於一種有趣的認知：無論多麼複雜，幾乎所有MAST結構都可以（或應該）包含一種條件：允許所有參與者就結果達成一致並一起簽署結算交易。在前面的例子中，如果Bob知道Alice可以在下週獨自動用所有資金，那麼他最好現在就跟她一起簽字。 （在許多典型的智慧合約設定中，如果他不這樣做，他甚至會受到懲罰。複雜性實際上只是為了讓每個人都誠實。）

Taproot類似於MAST，並且通常允許所有參與者可以合作來花費這筆資金，即“合作終止合約”。

而通過使用Schnorr簽名，它會變得非常有趣。

首先，合作終止合約將利用Schnorr簽名的閾值方法，讓它看起來像一筆普通交易。因此，所有參與者的公鑰會疊加生成“閾值公鑰”。與該閾值公鑰相對應的是，所有參與者簽名的組合——他們的“閾值簽名”——允許他們花費這些資金。

但他們唯一能做的就是把這筆資金當作一筆普通交易來使用——目前還沒有類似MAST的結構。這就是Schnorr簽名的另一個作用。

所有可選擇的資金使用方式（非合作結算）都會被合併到不同的指令碼中。然後，對這個指令碼進行雜湊處理，並使用它來調整閾值公鑰。與前面示例中使用的“公鑰x 2”不同，這將產生“閾值公鑰x指令碼”（尚在簡化當中）。當然，這個“閾值公鑰x指令碼”對應於“閾值簽名x指令碼”。

現在，如果資金是合作使用的，所有參與者都將他們的簽名組合成“閾值簽名”，並用指令碼對其進行調整。產生的“閾值簽名x指令碼”允許他們使用這筆資金。然而，重要的是，對於外人而言，所有的這些看起來仍然像一個普通的公鑰和一個常規的簽名，即一筆常規的交易。

只有在合作終止合約被證明是不可能的情況下，其他人才會知道這是閾值公鑰：它是經過調整的。

在這種情況下，原始閾值公鑰和指令碼將會被展示出來（因為剩餘參與者仍然希望能動用這筆資金）。這證明“閾值公鑰X指令碼”是用這個特定指令碼進行調整的。因此，就像P2SH中的雜湊值一樣，這種調整向全世界證明了，如果滿足指令碼中指定的其他條件，資金就應該是可花費的。

或者，與其用指令碼調整閾值公鑰，倒不如用默克爾樹的根值來調整閾值公鑰，默克爾樹的根值包含所有不同的可以使用資金的條件：MAST結構。那麼，要使用這些資金，只需要披露已經滿足的支出條件。

因此，Taproot能夠提供MAST的所有好處，而在正常情況下，沒有人會知道一筆常規交易背後隱藏瞭如此複雜的智慧合約。